EOL <- ';'

block <-
    '{'
    _ i:block_inner { $$ = i; } _
    '}' ~ { _cap_ERROR("block", "Expected closing '}' after block"); }

block_inner <-
    {
        cap_ps_push(auxil);
        auxil->stack->mark = BLOCK;
        auxil->stack->data = cst_ninit_Block(malloc(sizeof(struct cst_nBlock)), $0s, 0, cap_lno(auxil), cap_cno(auxil, $0s));
        _cap_ADDNODE(auxil->stack->data);
        $$ = _cap_LASTNODE;
    }
    line_inner*
    {
        assert(auxil->stack->mark == BLOCK);
        cst_NODEDOWNCAST(cap_ps_pop(auxil))->pos_end = $0e;
    }

line_inner <-
    s:body {
        cst_nBlock_addnode(auxil->stack->data, s);
    } / EOL {
        if (auxil->config.track_empty_lines)
            _cap_ADDNODE(_cap_MKINITNODE(ExtraData, "blank_eol", NULL, true));
    }

body <-
    ( ( n:block / n:block_statement ) _ EOL?
    / ( n:line_statement _ EOL ~ { _cap_ERROR("body", "Expected EOL ';' after line-statement"); }
      / n:expression _ EOL ~ { _cap_ERROR("body", "Expected EOL ';' after expression"); } ) )
    { $$ = n; }
