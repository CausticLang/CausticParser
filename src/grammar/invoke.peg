invoke <-
    p:invokation _ '(' _ { cap_ps_push(auxil); auxil->stack->mark = INVOKE_ARGS; }
        ( ( ( invokation_arg _ ',' _ )+ ( invokation_arg / ( invokation_kwargs ','? ) )? )
        / ( ( invokation_arg / invokation_kwargs ) _ ','? ) )?
    _ ')' ~ { _cap_ERROR("invoke", "Expected closing ')'"); } {
        struct cst_nProcInvoke* node = _cap_MKINITNODE(ProcInvoke, p, NULL, 0, NULL, 0);
        if (auxil->stack != NULL) {
            if (auxil->stack->mark == INVOKE_KWARGS) {
                node->kwarglen = auxil->stack->auxcount;
                node->kwargs = (struct cst_ProcKwarg**)cap_ps_pop(auxil);
            }
            assert(auxil->stack != NULL);
            assert(auxil->stack->mark == INVOKE_ARGS);
            node->arglen = auxil->stack->auxcount;
            node->args = cap_ps_pop(auxil);
        }
        _cap_ADDNODE(node);
        $$ = _cap_LASTNODE;
    }

invokation_arg <-
    v:expression {
        assert(auxil->stack->mark == INVOKE_ARGS);
        auxil->stack->data = realloc(auxil->stack->data, sizeof(cst_index*) * ++auxil->stack->auxcount);
        ((cst_index*)auxil->stack->data)[auxil->stack->auxcount-1] = v;
    } _ !'='

invokation_kwargs <-
    { cap_ps_push(auxil); auxil->stack->mark = INVOKE_KWARGS; }
    ( ( invokation_kwarg _ ',' _)+ invokation_kwarg?
      / invokation_kwarg )

invokation_kwarg <-
    k:expression _ '=' _ v:expression ~ { _cap_ERROR("invokation_kwarg", "Expected expression after '='"); } {
        assert(auxil->stack->mark == INVOKE_KWARGS);
        auxil->stack->data = realloc(auxil->stack->data, sizeof(struct Proc_Kwarg*) * ++auxil->stack->auxcount);
        struct cst_ProcKwarg* kw = malloc(sizeof(struct cst_ProcKwarg));
        kw->key = k; kw->val = v;
        ((struct cst_ProcKwarg**)auxil->stack->data)[auxil->stack->auxcount-1] = kw;
    }
